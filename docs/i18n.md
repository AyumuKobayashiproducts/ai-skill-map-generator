## Internationalization (i18n) Design

このアプリでは、`next-intl` を使って **日本語 / 英語の二言語対応** を実現しています。  
ここでは、実装ポリシーと新規ページ・コンポーネント追加時のガイドラインをまとめます。

---

## 1. ライブラリ & ルーティング構成

- ライブラリ: [`next-intl`](https://next-intl-docs.vercel.app/)
- ルーティング:
  - ロケール付きパス: `/[locale]/...`（`/ja/...`, `/en/...`）
  - ルートミドルウェア: `middleware.ts`
    - `/` にアクセスした場合は `/ja` にリダイレクト
    - `/ja/...`, `/en/...` 以外のパスをそれぞれのロケールに割り当て
- `app/[locale]/layout.tsx`
  - 各ロケール用の `NextIntlClientProvider` を設定
  - `@/src/messages/{locale}.json` から翻訳メッセージをロード

---

## 2. 翻訳ファイル構成

- ルート: `src/messages/ja.json`, `src/messages/en.json`
- 名前空間の例:
  - `home.*` … ホーム画面
  - `auth.login.*` / `auth.button.*` … 認証まわり
  - `dashboard.*` … ダッシュボード
  - `result.*` … 診断結果画面（タブ・グラフ・1on1 など）
  - `about.*`, `legal.*`, `portfolio.*` … 各ページ
  - `skillForm.*`, `skillStory.*`, `portfolioGen.*`, `skillCoach.*` … 主要コンポーネント
  - `ui.*` … 汎用 UI（エラーメッセージ / パンくずなど）
  - `layout.*` … ヘッダー / フッター / ナビゲーション

### キー設計ポリシー

- ページ単位 or 機能単位でトップレベルの名前空間を切る（例: `result.oneOnOne.history.empty`）。
- 短い UI テキストはフラットに、まとまった文章はオブジェクトでグルーピング。
- 配列的な文言（例: ヒント箇条書き / プランの Feature リスト）は `"a|b|c"` のように `|` 区切りで保存し、呼び出し側で `split("|")` して使用。

---

## 3. コンポーネントでの使い方

### サーバーコンポーネント (`getTranslations`)

```tsx
import { getTranslations } from "next-intl/server";

export default async function Page() {
  const t = await getTranslations("home");

  return (
    <h1>{t("hero.titleLine1")}</h1>
  );
}
```

### クライアントコンポーネント (`useTranslations`)

```tsx
"use client";

import { useTranslations } from "next-intl";

export function SkillForm() {
  const t = useTranslations("skillForm");

  return (
    <label>
      {t("skillInput.label")}
      <textarea placeholder={t("skillInput.placeholder")} />
    </label>
  );
}
```

---

## 4. 新しいページ / コンポーネント追加時の手順

1. **名前空間を決める**
   - 例: `/settings` ページ → `settings.*`
2. **翻訳キーを両方の JSON に追加**
   - `src/messages/ja.json` / `en.json` に同じ構造でキーを追加
3. **サーバー or クライアントで `t()` を呼ぶ**
   - サーバー: `getTranslations("settings")`
   - クライアント: `useTranslations("settings")`
4. **ハードコードされたテキストをすべて `t()` に置き換える**
   - 見出し、ボタン、ラベル、 aria-label などユーザーに見えるものが対象
5. **`/[locale]/...` へのルートを用意**
   - 多くの場合、`app/[locale]/xxx/page.tsx` で既存ページをラップするだけで OK:
   ```tsx
   import SettingsPage from "../../settings/page";

   export default function LocaleSettingsPage() {
     return <SettingsPage />;
   }
   ```

---

## 5. メタデータ / OGP のロケール対応

- ベースの `metadata` は `app/layout.tsx` に日本語で定義。
- ロケール別の上書きは `generateMetadata` で行う。
  - 例: `app/[locale]/layout.tsx` にて、`params.locale === "en"` の場合は英語タイトル・説明・OG 設定を返す。
- これにより、`/ja/...` を貼ると日本語のスニペット、`/en/...` を貼ると英語のスニペットが表示される。

---

## 6. テスト方針（i18n 観点）

- **E2E テスト（Playwright）**
  - `/ja` と `/en` の両ページを開き、主要な見出し・ボタン文言が切り替わっていることを確認。
  - LanguageSwitcher（JP / EN ボタン）で URL とテキストが変わることを検証。
- **ユニットレベル**
  - 必要に応じて、辞書のキー整合性チェック（`ja/en` 間でキーが欠けていないか）を行うテストを追加。

---

## 7. API レイヤーにおける i18n

- 現状、API ルートの `error` フィールドは主に日本語メッセージで、フロント側は `t(...)` ベースの UI エラーメッセージを使用。
- 本番サービス化する場合は、以下のような方針が考えられます。
  - リクエストヘッダ（例: `x-locale`）やセッションからロケールを判定。
  - サーバーサイドでも簡易的なエラーメッセージ辞書を用意し、`ja/en` を出し分ける。
  - もしくは、API は機械可読なエラーコードを返し、フロント側で i18n する。

このリポジトリでは「**フロント UI の i18n 完成度を重視**」しつつ、API レベルでは将来拡張可能な設計方針を README や本ドキュメントで説明することで、設計力・実装力の両方をアピールしています。






